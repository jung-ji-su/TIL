# Class & Constructor

#### 클래스(class)

	공통 요소들을 추상적이게 묶어놓은 틀,
	여러 변수들과 메소드들을 둘 다 관리하고 사용하기 위해 설계해 쓴다

#### 주어이다

		모든 문장 맨 앞에 클래스가 나오고
		영어는 맨 앞을 항상 대문자로 적는다.
		따라서 클래스는 주어이고, 대문자로 시작한다.

		String food = "banana";
		Monkey.eat(food);
		[주어][동사][목적어]

#### 타입이다.

		클래스는 추상적인 개념이고 이 클래스 안에는 필드가 존재한다.
		추상적인것을 바로 사용할 수 없기 때문에 그 필드들을
		구체화시킨 대상이 필요하다. 이러한 것들을 "객체"라고 부르고
		영어로는 instance variable 이라 부른다.

		instance 예, 예시이고 추상적인 개념의 한 예시로서 객체가
		나오기 때문에 instance variable이라 부른다.
		(자동차인데 예를 들어 내차)
		[클래스]	 	[객체]

		추상적인 개념의 클래스를 가지고 찍어내서 객체를 만드는 작업을
		객체화라고 한다.

		클래스명 객체명;
		따라서 클래스는 그 때 찍어내는 객체의 타입이다.

#### 클래스 선언

	다른 클래스 외부에서 선언한다.
	class 클래스명{
		필드선언(변수, 메소드)
	}

#### 클래스 사용

	클래스는 추상적인 틀이기 때문에 먼저 객체화를 진행한다.

	클래스명 객체명 = new 클래스명();
	객체.변수
	객체.메소드()

	하나의 저장공간에는 단 한개의 값만 담을 수 있다.
	필드에는 여러개의 값이 존재하기 때문에 필드는 다른곳(Heap)에
	할당되고 할당된 필드의 주소값을 저장하는 것이 객체이다.

#### 생성자

	클래스명 뒤의 소괄호
	생성자는 메소드와 똑같이 활용 가능하다.
	하지만 필드를 생성해주고 주소값을 돌려주기 때문에 메소드라고 부르지 않는다.
	리턴을 할 수가 없다.

	클래스 선언시 자동으로 생성자가 만들어지고 코드상에는 나타나지 않는다.
	이런 생성자를 기본생성자라고 하며, 만약 직접 생성자를 선언하게 되면
	기존에 있던 기본 생성자는 사라지게 된다.

	메소드 : 동사형 이름뒤에 소괄호
	클래스 : 명사형 이름 대문자로 시작
	생성자 : 명사형 이름 대문자로 시작하는 클래스 이름 뒤에 소괄호

#### 생성자의 목적

	1. 클래스의 필드를 똑같이 복사해서 메모리에 할당해주고 할당된
	필드의 주소값을 가지고 온다. 이 주소값을 객체에 담아놓고 사용한다. (객체화의 목적)

	2. 생성자는 호출시 내부의 내용을 모두 수행한다. (초기화의 목적)

#### this

	클래스 선언시 내부적으로 선언되어 생성된다.
	클래스 필드에서 한번의 메소드 선언으로 여러 객체를 다루어야 한다.
	만약 메소드 내에서 그 객체의 필드를 사용하고자 할 때 어떤 객체의 필드인지를
	알 수가 없다. 따라서 객체에 마침표를 찍거나, 객체를 생성하게 되면
	그 객체를 this 변수가 받는다. 결과적으로 클래스 선언시 this.필드명
	으로 접근하면 여러 객체도 하나의 메소드에서 구분하여 다룰 수 있게된다.
	this : 객체 구별용 변수 / 현재 접근중인 객체

#### 다형성(Polymorphism)

	1. Overloading(오버로딩)
		같은 이름의 메소드를 넘쳐서(여러개) 불러오는(선언하는) 기법
		매개변수의 개수 혹은 타입이 다르면 같은 이름의 메소드로
		여러개 선언할 수 있다. 이름이 아닌 매개변수로 구분하기 때문이다.
		오버로딩된 메소드를 사용할 시, 전달된 값의 타입 혹은 개수로
		구분하여 알맞은 메소드가 자동으로 호출된다.

     2. 오버라이딩(Overriding) : 재정의
		부모 필드에 이미 a()라는 메소드가 존재한다면
		자식 객체 생성시 부모 생성자가 먼저 호출되기 때문에
		부모 클래스의 a()가 먼저 메모리에 올라간다.
		그 다음 자식의 필드를 완성시킬 때 같은 이름의 a() 라는
		메소드가 선언되어 있다면, 같은 이름으로 두개가 만들어지는 것이
		아니고, 기존에 만들어진 부모 필드의 a() 메소드에 자식에서
		작성한 메소드 내용이 덮어 씌워진다. 그러므로 자식 객체로
		a() 메소드를 사용하게 되면 재정의된 기능으로 사용하며
		이것을 오버라이딩 이라고 한다.