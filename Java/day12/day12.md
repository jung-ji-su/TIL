# inheritance & Casting

### 상속(inheritance)

    1-1. 부모, 자식간의 상속관계를 설정할 수 있다.
    extends 키워드 사용하여 부모 클래스 이름을 명시한다.

    1-2. Overload
    원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상
    존재할 수 없지만, 이를 가능하게 하는 예외적인 처리 기법

### 객체 형변환(Casting)

2-1. 객체 형변환

    - java 기본 유형의 데이터들처럼 객체 참조변수의 경우에도 형변환(casting)이
    이루어진다.
    - 서로 다른 클래스 유형으로부터 나온 객체 참조변수들 간의 대입에는
    일정한 규칙이 있다.

    Parent parent = new Child();

    - 위의 대입연산에서 왼쪽 항(Parent)과 오른쪽 항(Child)의 객체 유형이
    서로 다른 경우, 두 유형이 서로 상속 관계에 있고 왼쪽 객체(Parent)가 오른쪽
    객체(Child)의 상위 클래스인 경우에만 암묵적인 형 변환이 일어난다.
    - 하위 클래스에서 상위클래스 유형으로 할당하는 것은 가능하나 그 반대의
    경우에는 명시적 형 변환을 해야한다.

2-2. 객체간의 암묵적 형변환

    - A a1 = new B();
    - A a2 = new X();
------------------------------
    - A a3 = new C();
    - A a4 = new Y();
------------------------------
    - B b1 = new C();
    - X x1 = new Y();
------------------------------
    - C c = new C();
      B b2 = c;
------------------------------
    - Y y = new Y();
      X x2 = y;

  2-3. 암묵적 형변환과 메서드 오버라이드

    - 암묵적 형변환은 부모를 상속받는 자식객체의 기능을 부모에게 물려받은 
    기능만 사용하도록 제한한다.
    - 그러므로 암묵적 형변환이 발생하게 되면 오버라이드된 기능만 사용가능하고,
    추가적으로 구현한 기능은 사용할 수 없다.
    - 주의할 점은 기능의 제한이지 기능의 변경은 아니라는 것이다.

   2-4. 암묵적 형변환 활용

    - 상속관계의 객체를 부모 형태로 변환하면 클래스의 종류를 구분하지 않고
    일관된 기능을 호출할 수 있고, 객체가 상위클래스형태로 형변환 되더라도
    Override된 자신의 기능은 잃지 않는다는것을 알게 되었다.

	Unit u1 = new Army();
	Unit u2 = new Navy();
	Unit u3 = new Airforce();

	u1.attack();
	u2.attack();
	u3.attack();
    
    - 하지만, 추가적으로 구현한 기능은 사용할 수 없게 되므로 원래의 기능을
    다시 사용할 수 있는 방법이 필요졌다.

  2-5. 명시적 형변환

    - 부모 클래스의 객체를 자식 클래스 형태로 변환하는 것
    - 형변환을 위해서는 다음과 같이 변환할 클래스 이름을 명시적으로
    지정해 주어야 한다.

    ChildClass child = (ChildClass)parent;

  2-6. 명시적 형변환의 조건

    - 객체가 최초 생성될 때 자식 클래스 형태로 생성되고, 
    부모 형태로 암묵적 형변환이 된 상태를 다시 원래의 자식 클래스 형태로
    되돌릴 경우에만 가능하다.

    ChildClass child1 = new ChildClass();
    ParentClass parent = child1;		// 암묵적 형변환
    ChildClass child2 = (ChildClass)parent;	// 명시적 형변환
    ------------------------------------------------------
    가능
    Army army1 = new Army();
    Unit u = army1;		
    Army army2 = (Army)u;
    ------------------------------------------------------
    가능
    Unit u = new Navy();
    Navy navy = (Navy) u;
    ------------------------------------------------------
    불가능 : 최초 객체 생성이 부모 형태로 만들어진 경우 불가능하다.
    Unit u = new Unit();
    Army army = (Army)u;
    -------------------------------------------------------
    불가능 : 최초 생성된 것과 다른 형식으로 변환하는 것은 불가능하다.
    Army army = new Army();
    Unit u = army;
    Navy navy = (Navy)u;
	
  2-7. 객체배열

    - 일반 데이터 타입의 배열과 동일한 개념으로,
    같은 클래스의 객체 여러 개를 그룹화 할 수 있다.
    - 일반 데이터 형의 배열 생성과 객체 배열 생성 비교

    일반 데이터 형 배열의 경우
    int[] data = new int[3];

    객체 배열의 경우
    Army[] data = new Army[3];

    - 각 경우에 대한 배열의 요소 할당처리
    -> 일반 데이터 형은 단순히 값을 대입하지만,
    객체 배열은 'new'를 사용하여 객체를 할당해야 한다.

    일반 데이터형의 배열의 경우
    data[0] = 10;
    data[1] = 2;
    data[2] = 9;

    객체 배열의 경우
    data[0] = new Army();
    data[1] = new Army();
    data[2] = new Army();

  2-8. 내용정리

    - 객체 형변환
    -> 같은 부모 클래스에서 파생된 서로다른 자식 클래스의
    객체들은 부모형태로 암묵적 형변환 되어 일관된 형식으로
    사용 가능하다.

    - 객체 배열
    -> 동일한 클래스의 객체는 배열루 묶어서 여러 개를 한꺼번에
    제어할 수 있다.

  2-9. 부모클래스의 배열에 자식 클래스의 객체를 넣기

    - 배열의 생성이 부모 클래스로 지정되었을 경우, 모든 자식 클래스의 객체들은
    그 배열에 포함될 수 있다.

    Unit[] unit = new Unit[3];

    // 배열의 요소 할당 과정에서 암묵적 형변환이 이루어진다.
    unit[0] = new Army();
    unit[1] = new Navy();
    unit[2] = new AirFore();

  2-10. 객체배열의 활용

    - 일괄 처리가 가능하다.
    -> 서로 다른 객체를 부모 형태의 배열에 담게 되면, 
    반복문으로 일괄처리가 가능하다.
    -> 이 때 배열의 각 요소를 통해 사용하는 메서드가 Override되어
    있을 경우, 부모의 메서드가 아니라 자신이 재정의한 기능을 뜻한다.

    for( int i = 0; i<unit.length; i++ ){
        unit[i].attack();
    }