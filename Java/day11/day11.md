# review

 1-1. 자료형(data type)

    8가지 
    boolean
    char
    byte
    short
    int
    long
    float
    double

 1-2. 연산자

    대입 연산자
    -> int money = 30000;

    사칙 연산자
    -> +, -, *, /, %

    단항 연산자
    -> x = x + 5; => x += 5;
    -> +=, -=, *=, /=, %=

    증감 연산자
    -> x = x +1;
    -> x += 1;
    -> x++;
    -> ++x;

    -> x = x -1;
    -> x -= 1;
    -> x--;
    -> --x;
    ---------------------------------------------
    int a = 100;
    int x = 1;
    int y = a + x++;
    y : 101
    x : 2

    int a = 100;
    int x = 1;
    int y = a + ++x;
    y : 102
    x : 2

    비교 연산자
    -> ==, !=, >, >=, <, <=
    -> 결과 값 boolean

    논리 연산자
    AND(&&)
    -> 모두 참인경우만 true
    OR(||)
    -> 둘중 하나라도 참인경우 true

    int a = 3;
    int b = 5;

    a > b : f
    (a != b) || (a == b) : t || f : t
    !(a == b) : !f : t
    !false : t


  1-4. 형변환

    데이터의 손실이 없다.
    암묵적 형변환, 명시적 형변환

  1-5.조건문

    if문
    if ~ else문
    if ~ else if ~ else문
    switch문

  1-6.반복문

    for
    while
    do ~ while
    무한 루프

  1-7. 배열

    변수를 그룹으로 묶은 형태의 한 종류, 사물함 같은 형태 갖고있다.
    1차 배열, 2차 배열
    일련번호
    행의 길이 : 배열이름.length;
    열의 길이 : 배열이름[행].length;

 1-8. 메서드

    프로그램의 함수 = 메서드
    메서드이름();

    메서드정의
    public static void 메서드이름(){
    ....
    }

    메서드 호출
    메서드이름();

    파라미터가 있는 메서드
    public static void 메서드이름(변수형 변수이름){
    ..
    }

    파라미터가 있는 메서드 호출
    메서드이름(값1);

    파라미터 = 매개변수

    메서드의 리턴값
    -> 메서드가 연산 결과를 자신이 호출된 위치에 반환하는 것을 
    "리턴"이라고 하며, 반환되는 값을 "리턴 값"이라고 한다.

    public static 리턴형 메서드이름(){
    ....
    return 리턴값;
    }

 1-9. 클래스

    클래스 : 객체를 생성하기 위한 객체의 설계도
    변수 
    -> 멤버변수(=전역변수)
    : 클래스 안에서 선언된 변수로서, 클래스 블록 범위 안에서
    유효하다

    -> 지역변수
    : 메서드 안에서 선언된 변수로서, 메서드의 블록을 빠져나가지 
    못한다. 그러므로 다른 메서드는 해당 변수를 인식하지 못한다.
    이 규칙은 조건, 반복문과같은 블록 {}를 형성하는 모든
    경우에 해당된다

  1-10. 생성자

    기본생성자
    new 키워드 사용하여 객체를 생성할 때, 자동으로 실행되는 특수한 형태의 메서드.
    리턴형을 명시하지 않는다.
    메서드의 이름은 클래스와 동일하다.
    자동으로 실행된다는 특성 때문에, 객체가 생성되면서 해당 객체의 특성을
    초기화 하기 위하여 사용된다.

	class Foo{
		Foo(){

		}
	}

	Foo f = new Foo();

    파라미터를 갖는 생성자
    생성자도 메서드의 한 종류이므로 파라미터를 함께 정의하는 것이 가능하다.

	class Foo{
		String name;
		int age;

		Foo( String name, int age ){
			this.name = name;
			this.age = age;
		}
	}

	Foo obj = new Foo("자바학생", 22);
	Foo obj2 = new Foo("JSP학생", 19);

 2-1. 은닉성이란?

    멤버변수나 메서드가 객체에 노출되지 않도록 설정하는 기법
    객체를 사용하는 측의 실수로 인한 기능의 오작동을 방지하기 위해, 클래스의
    일부를 숨기는 처리를 말한다.

 2-2. 적용방법

    변수의 이름이나 메서드 이름 앞에 "접근 한정자"를 지정한다.

    접근 한정자	            (설명)

    public		모든 곳에서 접근 가능하다.
                일반적으로 모든 메서드 앞에 명시한다.
    private		클래스 안에서만 사용가능하고, 객체를 통해 접근할 수
                없다. 일반적으로 모든 멤버변수 앞에 명시	
    protected	현재 클래스 내의 다른 자원이나, 같은 패키지 안에
                존재하는 클래스와 하위 클래스에서 접근 가능하다.
                잘 사용하지 않는다.
    default		접근 한정자를 명시하지 않은 경우. 현재 클래스 내의
                다른 자원이나 동일 패키지 내의 다른 클래스에서
                접근 가능하다. 잘 사용하지 않는다.

  2-3. getter, setter

    멤버변수가 은닉된 형태로 선언된 경우 프로그램의 가장 근본적인 목적인 
    데이터에 접근하는 방법이 사라지므로 메서드를 통하여 간접적으로 접근하는 방법이
    마련되어야 한다.
    getter, setter 는 은닉된 멤버변수에 간접적으로 접근하기 위하여
    정의된 메서드들을 의미하는 용어이다.

    -> getter
        : 은닉된 멤버변수의 값을 리턴하기 위한 메서드

    -> setter
        : 파라미터로 전달된 값을 멤버변수에 복사하기 위한 메서드

    메서드 작성 예 ex)

     (멤버변수 이름)	      (getter)			           (setter)
    String userName	    String getUserName()	void setUserName(String userName)
    int userAge	        int getUserAge()	    void setUserAge(int userAge)	

    -> 'get', 'set' 접두사 뒤에 변수이름을 첫 글자가 대문자인 형태로 명시
    -> getter는 연결된 멤버변수의 데이터 타입을 리턴형으로 명시
    -> setter는 연결된 멤버변수 데이터 타입을 파라미터 형으로 명시

    setter 
    -> 무결성 : 데이터의 정확성과 일관성을 유지하고 보증하는 것
    (ex: 물건의 가격은 음수일 수 없다. -> price 최소값이 0)
    -> 외부에서는 해당 집합의 세부 내용에 집중하지 않도록 함.

    getter
    -> 변수들의 외부 노출을 제한하고, 노출 범위를 정해주는 것
    -> 내부에서 가공된 값을 꺼낼 수 있다.
  
  2-4. 클래스에 접근 한정자를 지정한 경우

	접근한정자		   (설명)
	public		객체 생성이 가능하다. 
			    서로 다른 소스코드에 정의된 클래스끼리로 객체 생성이 가능하다.
	private		클래스에 적용할 수 없다.
	protected	클래스에 적용할 수 없다.
	default		동일한 소스코드(*.java)에 정의된 클래스끼리만 객체로 생성 가능하다.
			    (지금까지의 예제 형태)

    클래스의 분리
	-> 하나의 소스코드에서 프로그램의 모든 기능을 구현하게 되면
	유지보수에 비효율적이므로, 기능단위로 소스코드를 분리해야 한다.
	-> 소스코드가 분리된 클래스끼리는 public이 명시되어야만 서로 객체 생성이 가능하다.
	-> 일반적으로 클래스 정의에는 public 접근 한정자만 사용한다.
	-> 하나의 소스코드에는 하나의 public 클래스만 존재할 수 있다.

  2-5. 자바빈즈(JavaBeans)

    자바 언어에서 사용하는 복합적 데이터 표현의 최소 단위로서, 재사용 가능한 컴포넌트(구성요소)를
    생성할 수 있다.
    자바빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법 그리고 행동에 관련되
    일련의 관례를 따라야만 한다. 자바빈즈와의 연결을 통해 클래스의 사용과 재사용 그리고
    클래스의 재배치를 가능하게 한다.
    지켜야할 관례
    -> 클래스는 생성자를 가지고 있어야 한다.
    -> 클래스의 속성들은 get, set 혹은 표준 명명법을 따르는 메서드들을 사용해
    접근할 수 있어야 한다.