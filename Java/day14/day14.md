# static & pattern & package

### static

 1-1. static

    - static이 붙은 멤버변수는 객체의 개수에 상관 없이 단 하나만 생성되며,
    이를 모든 객체가 공유하기 때문에 메모리를 효율적으로 사용할 수 있다.

 1-2. 컴퓨터의 메모리 구조

    - 코드영역(고정영역)
    -> 프로그램의 코드가 저장되는 영역
    이 영역에 저장된 명령어들을 CPU가 하나씩 가져가 실행한다.

    - 데이터영역(고정영역)
    -> 전역변수와 static으로 선언되는 변수가 할당된다.
    이 영역에 할당되는 변수들은 프로그램 시작과 동시에
    메모리 공간이 할당되어 종료될 때까지 남아있게 된다.	

    - 힙영역(동적영역)
    -> 프로그래머가 원하는 시점에 변수를 할당하고 소멸시키는 영역.
    메모리 동적 할당시 사용된다. 객체가 생성되는 영역이다.

    - 스택영역(동적영역)
    -> 함수가 실행될 때 사용되는 파라미터와 지역변수에 대한
    메모리 공간. 함수의 종료와 함께 소멸된다.

  1-3. 고정영역, 동적영역

    - 고정영역
    -> 프로그램이 실행되면 실행파일이 메모리에 로드되면서,
    실행파일의 용량만큼 RAM을 사용한다.
    -> 실행 파일의 크기는 변할 수 없으므로 이 영역의 크기는 고정 크기를
    갖는다.

    - 동적영역
    -> 프로그래머가 new 키워드를 사용해서 객체나 배열을 생성하면 사용된다.
    -> 또 다른 경우는 메서드가 호출되는 동안 사용될 파라미터와 지역변수가
    생성된다.
    -> 메서드가 종료되거나 객체가 더이상 사용되지 않으면 생성된 변수나
    객체는 메모리에서 사라지므로, 이 영역은 유동적인 크기를 갖게 된다.

   1-4. 프로그램이 메모리를 사용하는 순서

    - 최초 실행시 고정 영역에 실행파일만큼의 메모리를 점유한다.
    - 프로그램이 각종 동작을 수행하는 동안 동적영역을 사용한다.

   1-5. 멤버변수와 static 멤버변수의 차이

    - static 변수는 프로그램의 실행과 동시에 객체의 생성 여부와 상관 없이
    이미 존재하기 때문에 소스 코드에서는 특정 클래스 안에 명시하지만,
    그 클래스를 통해서 생성되는 객체나 그 안에 포함되는 멤버변수와는 다른 존재이다.
    - 객체가 생성되지 않았더라도 이미 존재하고 있기 때문에 static 변수는
    객체의 이름을 통해 접근하는 것이 아니라, 클래스의 이름을 통해서 접근해야한다.
    - 단, static 변수가 선언된 클래스 안에서는 변수 이름으로 직접 접근이 허용된다.

	-> Article 클래스 및 다른 클래스에서 접근하는 경우
	Article.count = 3;
	Ariticle.category = "공지사항";

	-> Article 클래스에서 접근하는 경우
	count = 3;
	category = "공지사항";

   1-6. static 데이터에 접근하기 위한 메서드

    - 클래스에서 정의하는 일반 메서드들은 객체의 생성과 동시에 동적 메모리
    영역에서 활성화 된다.
	-> 동적 메모리 영역의 입장에서는 고정 메모리 영역의 자원들은
	항상 존재한다.
	-> 고정 메모리 영역의 자원들은 동적 메모리의 자원들이 항상
	존재하는 것이라는 보장을 받지 못한다.
    - 그러므로 객체의 생성과 상관 없이 static 변수에 접근하기 위한 메서드를
    만들 필요가 있는데, 메서드의 정의 과정에서 static 키워드를 사용하면
    static 자원에 접근하기 위한 메서드를 만들 수 있다.

###  디자인 패턴(Design Pattern)

  2-1. 디자인 패턴이란?

    - 디자인 패턴이란 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게
    풀어나갈 것인가에 대한 일종의 솔루션 같은 것이다. 
    - 디자인 패턴은 설계자들이 "올바른" 설계를 "빨리" 만들수 있도록 도와준다.

  2-2. Singleton 패턴

    - 프로그램 내의 여러 곳에서 반복적으로 사용되어야 하는 객체에 대해
    전역적인 범위를 갖도록 객체를 생성하고, 이 객체를 여러 곳에서 공유하기
    위한 클래스 작성 패턴
    - 이러한 패턴을 통해 생성된 객체를 싱글톤 객체라고 한다.

  2-3. SingleTon 객체의 이점

    - 프로그램의 전역에서 활용할 재료로 사용되는 공유 기능을 
    하나만 생성하여 여러 곳에서 재사용함으로 해서 메모리를 효율적으로 사용할 수 
    있다.
    - 단 한번만 객체를 생성하면 다시 객체를 생성할 필요가 없기 때문에, 
    해당 기능을 사용할 때마다 객체를 일일이 생성해야 하는 번거로움을 피할수 있다.

  2-4. 공통 기능을 포함할 클래스안에 스스로의 객체를 static으로 선언

    - static이 적용된 자원은 메모리의 고정영역에 생성되기 때문에,
    클래스 자체의 객체나, 그 안에 포함된 멤버변수, 메서드와는 메모리 상에서
    구별된다고 볼 수 있다.
    - 그러므로 Calc 클래스 안에 static 형태로 Calc 클래스의 객체를 정의하더라도
    코드상의 논리적인 연관관계를 위해 하나의 파일에서 정의하는 것일 뿐,
    실제로는 Calc 클래스 자체에서 독립된 객체가 되는 것이다.

    public class Calc{
        static Calc current;
    }

    - Calc 클래스 이외의 여러 곳에서 new 연산자를 사용하여 객체 할당이 가능하다면
    SingleTone 이라는 개념 자체가 성립되지 않으므로, 외부에서 이객체에 직접적인
    접근은 못하도록 은닉한다.

    public class Calc{
        private static Calc current;
    }

   2-5. 은닉된 객체를 할당하거나 메모리에서 삭제하는 기능 추가

    - current 객체를 private으로 지정하였기 때문에 객체를 메모리에서 
    간접적으로 할당하고 삭제하기 위한 메서드가 필요한다.
    - 객체를 메모리에서 제어하기 위해서는 null을 사용한다.

	public class Calc{
		private static Calc current;

		public static Calc getInstance(){
			if(current == null){
				current = new Calc();
			}

			return current;
		}

		public static void freeInstance(){
			current = null;
		}
	}

   2-6. new 연산자를 사용한 객체 할당 금지하기

    - 기본 생성자를 private 형태로 정의하면 객체 생성자가 은닉 처리되어
    외부에서 new 연산자를 사용한 객체 할당이 금지된다.
	
	public class Calc{
		private static Calc current;

		public static Calc getInstance(){
			if(current == null){
				current = new Calc();
			}

			return current;
		}

		public static void freeInstance(){
			current = null;
		}

		private Calc(){}
	}

  2-7. 싱글톤 객체 사용하기

    - getInstance() 메서드를 사용하여 객체를 리턴 받는 형식으로 사용한다.
    - 여러 개의 객체를 리턴 받더라도 모두 하나의 static 객체를 참조하게 되기 때문에
    전역 객체 하나만이 메모리에 할당되게 된다.

    // 1. 별도의 객체에 참조시키는 경우
    Calc c = Calc.getInstance();
    // 메서드 사용하기
    c.plus(100, 200);

    // 2. 참조처리를 생략하고 직접 사용하는 경우
    Calc.getInstance().plus(100, 200);

###  Package

 3-1. Package

    - 패키지 -> 클래스에 대한 묶음 단위
    - 클래스를 용도별이나, 기능별로 그룹화 한것을 말한다.
    - 서로 다른 패키지에 속해 있다면 다른 클래스와 이름이 동일하더라도
    충돌이 발생하지 않는다.
    ( 서로 다른 폴더에는 이름이 같은 파일들이 존재할 수 있다.)
    - 패키지 이름의 일반적인 정의 형식
    -> 회사 도메인이름의 역순, 프로젝트 이름의 소문자
    (ex: com.koreait.academy.article)
	

 3-2. 패키지에 속해 있는 클래스에 대한 객체 생성

    - 다른패키지의 클래스를 포함하고자 할 경우,
    패키지 이름을 포함한 FullName으로 사용해야 한다.
    - 이러한 번거로움을 피하고자 클래스 정의 전에 import 구문을 사용하여
    특정 클래스 이름이 어떤 패키지에 소속되어 있는지를 명시할 수 있다.